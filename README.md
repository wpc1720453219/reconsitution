# reconsitution
重构：改善既有代码的设计（第2版） 总结

## 第一章 重构，第一个示例
### 1.2
如果你要给程序添加一个特性，但发现代码因缺乏良好的结构而不易于进行更改，那就先重构那个程序，使其比较容易添加该特性，   然后再添加该特性
### 1.3
重构前，先检查自己是否有一套可靠的测试集。这些测试必须有自我检验能力。 与重构后测试对比
### 1.6
拆分阶段（154）:将逻辑分成两部分：一部分计算详单所需的数据，另一部分将数据渲染成 文本或HTML
第一阶段会创建一个中转数据结构，再把它传递给第二阶段。
总的来说： 过去在**印详单里调用相关的逻辑数据计算直接呈现出来**,
1.6 先进行计算出来将处理后的数据封装到实体类， 后通过调用文本或HTML方法呈现出来（将数据 与视图呈现分开）
### 1.7
增加了HTML视图模式，现有两种数据呈现方式，纯文本和HTML
### 1.8与1.9
创建个PerformanceCalculator数据结构进行以多态的形式调用封装
![alt 封装](./image/Snipaste_2022-05-07_14-00-20.png)
![alt 封装](./image/Snipaste_2022-05-07_14-00-34.png)
### 1.10
好代码的检验标准就是人们是否能轻而易举地修改它。好代码应该直截了当：有人需要修改代码时，他们应能轻易找到修改点，应该能快速做出更改，而不易引入其他错误
## 第二章 重构的原则
###2.1何谓重构  
1.重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本  
2.重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。  
3.重构的关键在于运用大量微小且保持软件行为的步骤，一步步达成大规模的修改。每个单独的重构要么很小，要么
由若干小步骤组合而成。因此，在重构的过程中， 我的代码很少进入不可工作的状态，即便重构没有完成，我也可以在任何时刻停下来。  
4.如果有人说他们的代码在重构过程中有 一两天时间不可用，基本上可以确定，他们在做的事不是重构。  
5.重构与性能优化两者的差别在于其目的：重构是为了让代码“更容易理解，更易于修改”。这可能使程序运行得更快，也可能使程序运行得更慢。在性能优化时，我只关心让程序运行得更快，最终得到的代码有可能更难理解和维护，对此我有心理准备。
###2.3为何重构
我不想把重构说成是包治百病的万灵丹，它绝对不是所谓的“银弹”。不过它的确很有价值，尽管
它不是一颗“银弹”，却可以算是一把“银钳子”，**可以帮你始终良好地控制自己的代码**。
设计欠佳的程序往往需要更多代码，这常常是因为代码在不同的地方使用完全相同的语句做同样的事,消除重复代码，方法复用  
###2.4何时重构
1.事不过三，三则重构 第一次做某件事时只管去做；第二次做类似的事会产生反感，但无论如何还是可以去做；第三次再做类似的事，你就应该重构  
2.重构的最佳时机就在添加新功能之前,修改过去的参数结构，而不是整个函数复制过来，修改这几个值  
3.如果一块代码我很少触碰，它不会经常给我带来麻烦，那么我就倾向于不去重构它  
4.花在重构的时间是在拖慢新功能的开发进度。“重构会拖慢进度”这种看法仍然很普遍，这可能是导致人们没有充分重构的最大阻力所在
我们之所以重构，因为它能让我们更快——添加功能更快，修复bug更快。一定要随时记住这一点，与别人交流
时也要不断强调这一点。重构应该总是由经济利益驱动。程序员、经理和客户越理解这一点，“好的设计”那条曲线就会越经常出现。  
**复用一个逻辑方法，但传参不对，可以增加修改此方法入参，而不是复制此方法，重新创造一个方法**
###2.8重构与性能
在性能优化阶段，我首先应该用一个度量工具 来监控程序的运行，让它告诉我程序中哪些地方大 量消耗时间和空间。 这样我就可以找出性能热点所 在的一小段代码。
然后我应该集中关注这些性能热 点，并使用持续关注法中的优化手段来优化它们。 由于把注意力都集中在热点上，较少的工作量便可 显现较好的成果
##代码的坏味道
1.神秘命名（不能表达含义）  
2.重复代码  
3.过长函数  
每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名。
我们可以对一组甚至短短一行代码做这件事。哪怕替换后的函数调用动作比函数自身还长，只要函数名称能够解释其用途，我们也该毫不犹豫地那么
做。关键不在于函数的长度，而在于函数“做什么”和“如何做”之间的语义距离
4.
